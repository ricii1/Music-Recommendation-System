# -*- coding: utf-8 -*-
"""RecommendationSystem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BcQCKc30oOnD_w8Jri0DqhNG6lOiMm6k

# Project 2 Dicoding Machine Learning Terapan: Music Recommendation System
### Nama: Junathan Richie
### Email: jonathanrichie05@gmail.com
### Username: junathan_richie_NU9i

### Importing Data
"""

!kaggle datasets download joebeachcapital/30000-spotify-songs

!unzip -o 30000-spotify-songs.zip

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
raw_data = pd.read_csv("spotify_songs.csv")
raw_data.head()

"""Karena keterbatasan RAM dalam komputasi, maka data yang diambil hanya 15000 lagu dengan track_popularity tertinggi."""

raw_data = raw_data.sort_values(by="track_popularity", ascending=False)
raw_data

raw_data = raw_data.head(15000).reset_index(drop=True)
raw_data

"""### Data Understanding

Keterangan Data dari kaggle:
- track_id: id unik dari lagu
- track_name: nama lagu
- track_artist: artis
- track_popularity: popularitas lagu dari range 1-100
- track_album_id: id unik dari album lagu
- track_album_name: nama dari album lagu
- track_album_release_date: tanggal rilis album
- playlist_name: nama dari playlist
- playlist_id: id playlist
- playlist_genre: genre dari playlist
- playlist_subgenre: subgenre dari playlist
- danceability: seberapa cocok sebuah lagu untuk ditarikan berdasarkan tempo, ritme, ketukan, dan lainnya. Nilai 1.0 berarti paling dapat ditarikan sedangkan 0.0 berarti tidak dapat ditarikan
- energy: energi diukur dalam rentang 0.0 hingga 1.0. Lagu yang energik terasa cepat, keras, dan berisik. Lagu dengan nilai energy tinggi seperti lagu death metal dan lagu dengan nilai energy rendah seperti Bach prelude.
- key: estimasi kunci keseluruhan track yang dipetakan dalam integer seperti 0 = C, 1 = C♯/D♭, 2 = D, dan seterusnya.
- loudness: kekerasan suara dari rata-rata seluruh track. Dalam rentang -60dB hingga 0dB.
- mode: menunjukkan modality (mayor atau minor) dari lagu. Mayor dilambangkan dengan 1 dan minor dilambangkan dengan 0.
- speechiness: menunjukkan seberapa banyak kata-kata yang diucapkan dalam track pada rentang 0.0 hingga 1.0. Semakin dekat dengan nilai 1.0 berarti semakin banyak kata yang diucapkan sehingga track itu mungkin saja sebuah podcast, audiobook, dan sebagainya. Nilai di atas 0,66 menggambarkan track yang mungkin seluruhnya terdiri dari kata-kata yang diucapkan. Nilai antara 0,33 dan 0,66 menggambarkan track yang mungkin berisi musik dan ucapan, baik dalam beberapa bagian atau berlapis, termasuk kasus seperti musik rap. Nilai di bawah 0,33 kemungkinan besar mewakili musik dan track lain yang tidak ada ucapan.
- acousticness: ukuran kepercayaan apakah sebuah lagu akustik, nilai 1.0 berarti sangat diyakini bahwa lagu itu adalah lagu akustik.
- instrumentalness: ukuran kepercayaan apakah sebuah lagu bersifat non-vocal (hanya instrumental). Semakin  mendekati nilai 1.0 berarti semakin diyakini bahwa track tersebut adalah instrumental
- liveness: liveness mendeteksi apakah ada penonton pada track itu. Apabila ada penonton, maka track tersebut cenderung dibuat secara live. Nilai di atas 0.8 menunjukkan bahwa sangat diakini bahwa track tersebut dibuat secara live.
- valence: digunakan untuk mengukur tingkat musical positiveness dari sebuah track. Track dengan nilai valence tinggi menunjukkan track terdengar positive (happy, cheerful) sedangkan nilai valence rendah menunjukkan track memiliki terdengar negative.
- tempo: perkiraan tempo dari keseluruhan track dalam BPM (beats per minute)
- duration_ms: durasi lagu dalam milliseconds

#### Explaratory Data Analysis
"""

raw_data.info()

"""Berdasarkan info tersebut, tipe data dari data adalah object, int64, dan float64. Data object ini berarti data yang berupa kategorial dan harus dikodekan nantinya."""

raw_data.describe()

"""Hasil dari describe tidak menunjukkan adanya keanehan pada data."""

jumlah_track = len(raw_data.track_id.unique())
jumlah_artis = len(raw_data.track_artist.unique())
jumlah_album = len(raw_data.track_album_id.unique())
print(f"Banyak track pada data: {jumlah_track}")
print(f"Banyak artis pada data: {jumlah_artis}")
print(f"Banyak album pada data: {jumlah_album}")

data = pd.DataFrame({
    "Kategori": ["Track", "Artis", "Album"],
    "Jumlah": [jumlah_track, jumlah_artis, jumlah_album]
})

sns.barplot(x="Kategori", y="Jumlah", data=data, palette="pastel", legend=False)
plt.title("Jumlah Track, Artis, dan Album")
plt.xlabel("Kategori")
plt.ylabel("Jumlah")
plt.show()

"""##### Popularity"""

popularity_counts = raw_data["track_popularity"].value_counts().reset_index()
popularity_counts.columns = ["popularity", "count"]

# Plot
plt.figure(figsize=(17, 10))
sns.barplot(
    x="popularity",
    y="count",
    data=popularity_counts.sort_values(by="popularity"),
    palette="rocket_r"
)
plt.title("Distribusi Jumlah Lagu Berdasarkan Popularitas")
plt.xlabel("Popularity")
plt.ylabel("Jumlah Lagu")
plt.xticks(rotation=45)
plt.show()

"""Terlihat bahwa sebagian besar data tersebar di antara 49-71. Data dengan popularity 95 ke atas sangat sedikit.

##### Track Album Release Date

Agar EDA lebih sederhana, buat visualisasi hanya berdasarkan tahun saja.
"""

def parse_date(date):
    try:
        if len(date) == 4:
            return pd.to_datetime(date, format='%Y')
        elif len(date) == 7:
            return pd.to_datetime(date, format='%Y-%m')
        elif len(date) == 20:
            return pd.to_datetime(date, format='%Y-%m-%d %H-%M-%s')
        else:
            return pd.to_datetime(date, format='%Y-%m-%d')
    except:
        print(date)
        return pd.NaT

raw_data["track_album_release_date"] = raw_data["track_album_release_date"].apply(parse_date)
raw_data

year_counts = raw_data.track_album_release_date.dt.year.value_counts().reset_index()
year_counts.columns = ["year", "count"]

# Plot
plt.figure(figsize=(17, 6))
sns.barplot(
    x="year",
    y="count",
    data=year_counts.sort_values(by="year"),
    palette="pastel",
)
plt.title("Distribusi Jumlah Lagu Berdasarkan Tahun")
plt.xlabel("Year")
plt.ylabel("Jumlah Lagu")
plt.xticks(rotation=45)
plt.show()

"""Data di atas menunjukkan sebagian besar track berada pada tahun 2015 ke atas dan terbanyak pada tahun 2019.

##### Playlist
"""

jumlah_playlist = len(raw_data.playlist_id.unique())
jumlah_genre = len(raw_data.playlist_genre.unique())
jumlah_subgenre = len(raw_data.playlist_subgenre.unique())
print(f"Jumlah playlist: {jumlah_playlist}")
print(f"Contoh Nama playlist: {pd.Series(raw_data['playlist_name'].unique()).sample(5).to_list()}")
print(f"Jumlah genre: {jumlah_genre}")
print(f"Nama genre: {raw_data.playlist_genre.unique()}")
print(f"Jumlah subgenre: {jumlah_subgenre}")
print(f"Nama subgenre: {raw_data.playlist_subgenre.unique()}")

genre_counts = raw_data.playlist_genre.value_counts().reset_index()
genre_counts.columns = ["genre", "count"]
plt.pie(genre_counts["count"], labels=genre_counts["genre"], autopct='%1.1f%%', startangle=140, colors=sns.color_palette('Set2'))
plt.title('Playlist Genre Distribution')
plt.show()

"""Perbandingan Genre terlihat didominasi oleh lagu pop. Lagu edm menjadi lagu dengan distribusi paling rendah."""

subgenre_counts = raw_data.playlist_subgenre.value_counts().reset_index()
subgenre_counts.columns = ["subgenre", "count"]
# Plot
plt.figure(figsize=(10, 10))
plt.pie(subgenre_counts["count"], labels=subgenre_counts["subgenre"], autopct='%1.1f%%', startangle=140, colors=sns.color_palette('Set2'))
plt.title('Playlist Subgenre Distribution')
plt.show()

"""Sub-genre didominasi track-track seperti hip hop, urban contemporary, dan jenis-jenis pop. Sub-genre new jack swing dan big room memiliki pembagian paling kecil.

#### Duration
"""

raw_data['duration_min'] = raw_data['duration_ms'] / (1000 * 60)

plt.figure(figsize=(15, 6))
sns.histplot(raw_data['duration_min'], bins=100, kde=True, color='blue')
plt.title('Distribusi Durasi Track Musik (dalam Menit)')
plt.xlabel('Durasi (menit)')
plt.xticks(ticks=np.arange(0, raw_data['duration_min'].max()+0.5, 0.5))
plt.ylabel('Jumlah Track')
plt.show()

"""Sebagian besar track berada pada durasi 3-4 menit

##### Key
"""

key_counts = raw_data.key.value_counts().reset_index()
key_counts.columns = ["key", "count"]
# Mapping key agar hasil semakin dapat dalam bentuk key sebenarnya
key_counts["key"] = key_counts["key"].map({
    0: "C",
    1: "C#",
    2: "D",
    3: "D#",
    4: "E",
    5: "F",
    6: "F#",
    7: "G",
    8: "G#",
    9: "A",
    10: "A#",
    11: "B"
})
print(key_counts)
plt.figure(figsize=(10, 10))
plt.pie(key_counts["count"], labels=key_counts["key"], autopct='%1.1f%%', startangle=140, colors=sns.color_palette('Set2'))
plt.title('Track Key Distribution')
plt.show()

"""Nada dasar C, C#, dan G menjadi nada dasar yang paling banyak digunakan dalam track lagu. Nada D# menjadi nada dasar yang paling sedikit digunakan. Hal ini menunjukkan distribusi preferensi kunci dari komposer ketika membuat lagu.

##### Mode
"""

mode_counts = raw_data["mode"].value_counts().reset_index()
mode_counts.columns = ["mode", "count"]
# Mapping agar hasil dalam bentuk string
mode_counts["mode"] = mode_counts["mode"].map({
    0: "Minor",
    1: "Major"
})
print(mode_counts)
plt.figure(figsize=(8, 8))
plt.pie(mode_counts["count"], labels=mode_counts["mode"], autopct='%1.1f%%', startangle=140, colors=sns.color_palette('Set2'))
plt.title('Mode Distribution')
plt.show()

"""Mode menunjukkan lebih banyak track memiliki nada dasar major.

##### Music Characteristic
"""

plt.figure(figsize=(15, 6))
sns.histplot(raw_data['danceability'], bins=100, kde=True, color='green')
plt.title('Danceability Distribution')
plt.xlabel('Nilai Danceability')
plt.xticks(ticks=np.arange(0, 1.1, 0.1))
plt.ylabel('Jumlah Track')
plt.show()

"""Penyebaran danceability yang condong data terpusat di kanan terutama di sekitar nilai 0.6 - 0.8 atau bisa disebut _negatively skewed distribution_ menggambarkan bahwa sebagian besar track memiliki sifat danceability yang tinggi."""

plt.figure(figsize=(15, 6))
sns.histplot(raw_data['energy'], bins=100, kde=True, color='brown')
plt.title('Energy Distribution')
plt.xlabel('Nilai Energy')
plt.xticks(ticks=np.arange(0, 1.1, 0.1))
plt.ylabel('Jumlah Track')
plt.show()

"""Penyebaran energy juga berbentuk _negatively skewed distribution_ dengan data terpusat di kanan di sekitar nilai 0.6 - 0.9. Sebagian besar track memiliki nilai energy yang tinggi."""

plt.figure(figsize=(15, 8))
sns.histplot(raw_data['loudness'], bins=100, kde=True, color='purple')
plt.title('Loudness Distribution')
plt.xlabel('Nilai Loudness')
plt.xticks(ticks=np.arange(-60, 5, 2.5))
plt.ylabel('Jumlah Track')
plt.show()

"""Penyebaran loudness ekstrim di daerah -7.5 - -2.5 berarti sebagian besar track memiliki tingkat suara yang keras."""

plt.figure(figsize=(15, 6))
sns.histplot(raw_data['speechiness'], bins=100, kde=True, color='orange')
plt.title('Speechiness Distribution')
plt.xlabel('Nilai Speechiness')
plt.xticks(ticks=np.arange(0, 1.1, 0.1))
plt.ylabel('Jumlah Track')
plt.show()

"""Penyebaran speechiness ekstrim di bagian kiri di daerah 0 hingga 0.1 yang berarti sebagian besar track dinyanyikan dan sangat sedikit kata-kata yang diucapkan dalam track tersebut."""

plt.figure(figsize=(15, 6))
sns.histplot(raw_data['instrumentalness'], bins=100, kde=True, color='red')
plt.title('Intrumentalness Distribution')
plt.xlabel('Nilai Intrumentalness')
plt.xticks(ticks=np.arange(0, 1.1, 0.1))
plt.ylabel('Jumlah Track')
plt.show()

"""Penyebaran instumentalness sangat ekstrim dengan 12000 lebih data berada di antara nilai 0.0 yang berarti lebih dari 3/4 data sangat diyakini bahwa track tersebut memiliki vocal di dalamnya."""

plt.figure(figsize=(15, 6))
sns.histplot(raw_data['liveness'], bins=100, kde=True, color='green')
plt.title('Liveness Distribution')
plt.xlabel('Nilai Liveness')
plt.xticks(ticks=np.arange(0, 1.1, 0.1))
plt.ylabel('Jumlah Track')
plt.show()

"""  Liveness memiliki penyebaran data condong di daerah kiri di antara nilai 0.1 yang berarti sebagian besar track pada data tidak dinyanyikan secara live."""

plt.figure(figsize=(15, 6))
sns.histplot(raw_data['valence'], bins=100, kde=True, color='cyan')
plt.title('Valence Distribution')
plt.xlabel('Nilai Valence')
plt.xticks(ticks=np.arange(0, 1.1, 0.1))
plt.ylabel('Jumlah Track')
plt.show()

"""Valence memiliki penyebaran yang merata."""

plt.figure(figsize=(15, 6))
sns.histplot(raw_data['acousticness'], bins=100, kde=True, color='red')
plt.title('Acousticness Distribution')
plt.xlabel('Nilai Acousticness')
plt.xticks(ticks=np.arange(0, 1.1, 0.1))
plt.ylabel('Jumlah Track')
plt.show()

"""Acousticness memiliki penyebaran data ekstrim di sebelah kiri yang berarti sebagian besar track bukan lagu akustik."""

plt.figure(figsize=(15, 6))
sns.histplot(raw_data['tempo'], bins=100, kde=True, color='blue')
plt.title('Tempo Distribution')
plt.xlabel('Nilai Tempo')
plt.xticks(np.arange(0, 260, 10))
plt.ylabel('Jumlah Track')
plt.show()

"""Tempo lagu tersebar cukup merata pada nilai 70-200 dan memiliki 2 puncak. Puncak pertama pada rentang data 90-100 dan puncak kedua pada rentang data 120-130.

### Data Preparation

#### Pengecekan dan Drop Data Null dan Duplicate
"""

raw_data.isnull().sum()

"""Karena tidak ada data null maka dapat dilanjutkan ke tahap selanjutnya yaitu pengecekan data duplicate."""

duplicates_by_track_id = raw_data[raw_data.duplicated(subset=['track_id'], keep=False)]
duplicates_sorted_track_id = duplicates_by_track_id.sort_values(by='track_id')
duplicates_sorted_track_id

"""Dari data di atas, terlihat bahwa track_id duplicate menunjukkan bahwa track tersebut sama. Data duplicate ini harus didrop untuk menghidari rekomendasi yang bersifat duplicate."""

# Drop data
removed_duplicates_by_id = raw_data.drop_duplicates(subset=['track_id'], keep='first')
removed_duplicates_by_id.info()
# Check duplicates
duplicates_by_track_id = removed_duplicates_by_id[removed_duplicates_by_id.duplicated(subset=['track_id'], keep=False)]
duplicates_sorted_track_id = duplicates_by_track_id.sort_values(by='track_id')
duplicates_sorted_track_id

"""Drop data berdasarkan track_id berhasil."""

# Check duplicates berdasarkan track name dan artists
duplicates_by_track_name_and_artist = removed_duplicates_by_id[removed_duplicates_by_id.duplicated(subset=["track_name", "track_artist"], keep=False)]
duplicates_sorted = duplicates_by_track_name_and_artist.sort_values(by='track_name')
duplicates_sorted

"""Ternyata selain dari track_id, ada data musik yang masih sama juga berdasarkan name dan artist-nya. Maka, saya menghapus data duplicate dan mengambil data dengan popularity tertinggi."""

# Menghapus duplikat dengan memilih track_popularity tertinggi
cleaned_data = (
    removed_duplicates_by_id.loc[
        removed_duplicates_by_id.groupby(["track_name", "track_artist"])["track_popularity"].idxmax()
    ]
).reset_index(drop=True)
duplicates_by_track_name_and_artist = cleaned_data[cleaned_data.duplicated(subset=["track_name", "track_artist"], keep=False)]
duplicates_sorted = duplicates_by_track_name_and_artist.sort_values(by='track_name')
duplicates_sorted

"""Drop data berhasil"""

cleaned_data

cleaned_data.info()

"""#### Drop Kolom Tidak Relevan

track_id tidak penting karena tidak memberikan informasi apa-apa mengenai track sehingga dapat didrop. Selain itu, data_track_album_id, playlist_id, data track_album_name dan playlist_name merupakan metadata yang tidak digunakan secara langsung pada sistem rekomendasi dan dapat didrop.
"""

cleaned_data.drop(columns=['track_id','track_album_name', 'playlist_name', 'track_album_id', 'playlist_id'], inplace=True)
cleaned_data.info()

"""track_popularity, liveness, duration, release_date tidak berpengaruh terhadap sebuah karakteristik musik sedangkan sistem rekomendasi yang dibuat akan berdasarkan karakteristik musik sehingga ketiga aspek ini dapat didrop."""

cleaned_data.drop(columns=["track_popularity","liveness","duration_min","duration_ms", "track_album_release_date"], inplace=True)
cleaned_data.info()

"""#### Penyederhanaan Data

Ubah data yang berhubungan dengan kepercayaan seperti acousticness dan instrumentalness agar menjadi 0 dan 1.
"""

cleaned_data.loc[cleaned_data["acousticness"] <= 0.5, "acousticness"] = 0
cleaned_data.loc[cleaned_data["acousticness"] > 0.5, "acousticness"] = 1
cleaned_data.loc[cleaned_data["instrumentalness"] <= 0.5, "instrumentalness"] = 0
cleaned_data.loc[cleaned_data["instrumentalness"] > 0.5, "instrumentalness"] = 1
cleaned_data

"""#### Standarisasi Data Numerik

Normalisasi data dari kolom numerik dengan MinMaxScaler
"""

from sklearn.preprocessing import MinMaxScaler
numerical_cols = ["danceability", "energy", "key", "loudness", "speechiness", "acousticness", "instrumentalness", "valence", "tempo", "mode"]
scaler = MinMaxScaler()
data_normalized = cleaned_data.copy()
data_normalized[numerical_cols] = scaler.fit_transform(data_normalized[numerical_cols])
data_normalized

"""#### Encoding Data Kategori

Kodekan data kategorial dengan One Hot Encoder. Data kategorial yang dikodekan hanya playlist_subgenre karena playlist_subgenre sudah mewakili playlist_genre dan bersifat lebih spesifik.
"""

from sklearn.preprocessing import OneHotEncoder
encoder = OneHotEncoder(sparse_output=False)
genre_encoded = encoder.fit_transform(data_normalized[['playlist_subgenre']])

encoded_df = pd.DataFrame(genre_encoded, columns=encoder.get_feature_names_out(['playlist_subgenre']))

data_encoded = pd.concat([data_normalized.drop('playlist_subgenre', axis=1), encoded_df], axis=1)
data_encoded

"""### Model Development"""

from sklearn.metrics.pairwise import euclidean_distances
features = numerical_cols + list(encoded_df.columns)
euclidean_dist = euclidean_distances(data_encoded[features])
euclidean_sim = 1 / (1 + euclidean_dist)
euclidean_sim

euclidean_sim.shape

from sklearn.metrics.pairwise import cosine_similarity
cosine_sim = cosine_similarity(data_encoded[features])
cosine_sim

cosine_sim.shape

def get_song_recommendations(track_name, track_artist, pairwise_metrics, dataset, top_n=10):
    # Mengecek apakah kombinasi track_name dan track_artist ada dalam dataset
    track_match = dataset[
        (dataset['track_name'] == track_name) &
        (dataset['track_artist'].str.contains(track_artist, case=False))
    ]

    if track_match.empty:
        raise ValueError("Lagu tidak ditemukan atau artis tidak cocok.")

    # Mengambil indeks lagu berdasarkan kombinasi yang cocok
    track_idx = track_match.index[0]
    print(f"track_idx: {track_idx}")

    # Memastikan bahwa track_idx berada dalam rentang yang valid pada pairwise_metrics
    if track_idx >= pairwise_metrics.shape[0]:
        raise IndexError("Indeks lagu tidak valid dalam matriks kesamaan.")

    # Mendapatkan nilai similarity untuk lagu yang dimasukkan
    sim_scores = list(enumerate(pairwise_metrics[track_idx]))

    # Mengurutkan similarity dari yang tertinggi
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Mengambil 10 lagu teratas kecuali lagu yang dimasukkan
    sim_scores = sim_scores[1:top_n+1]

    # Mendapatkan indeks lagu yang direkomendasikan
    song_indices = [i[0] for i in sim_scores]
    recommended_songs = dataset.iloc[song_indices].copy()
    recommended_songs.loc[:, 'similarity_score'] = [score[1] for score in sim_scores]
    # Menggabungkan hasil dalam format yang sesuai
    return recommended_songs

data_normalized[data_normalized["track_name"] == "Secukupnya"]

input_track_name = "Secukupnya"
input_track_artist = "Hindia"
print(f"Rekomendasi lagu untuk '{input_track_name}' - {input_track_artist}:")
recommended_songs = get_song_recommendations(input_track_name, input_track_artist, euclidean_sim, data_normalized, 5)
recommended_songs

input_track_name = "Secukupnya"
input_track_artist = "Hindia"
print(f"Rekomendasi lagu untuk '{input_track_name}' - {input_track_artist}:")
recommended_songs = get_song_recommendations(input_track_name, input_track_artist, cosine_sim, data_normalized, 5)
recommended_songs